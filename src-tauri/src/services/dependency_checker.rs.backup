//! 依赖项检测服务
//!
//! 负责检测系统依赖是否满足要求:
//! - 检测Node.js/pnpm/Redis版本
//! - 检测Playwright浏览器
//! - 版本比较和验证
//! - 并发检测协调和进度事件发射

use crate::models::{dependency::*, errors::*};
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::Mutex;
use tauri::{AppHandle, Manager};
use tracing::{info, warn, error, debug};

/// 依赖检测服务
pub struct DependencyChecker;

impl DependencyChecker {
    /// 创建新的检测服务
    pub fn new() -> Self {
        Self
    }

    /// 检测所有依赖项
    pub async fn check_all(&self) -> Result<Vec<Dependency>, ApiError> {
        // TODO: 实现依赖检测逻辑
        todo!("检测所有依赖项")
    }

    /// 并发检测所有依赖项
    ///
    /// 使用 Tokio 并发模式同时检测多个依赖项，每个依赖项在独立任务中执行
    /// 每完成一个检测就发射进度事件到前端
    ///
    /// # 参数
    ///
    /// * `app` - Tauri 应用句柄，用于发射事件
    /// * `deps` - 待检测的依赖项列表
    ///
    /// # 返回
    ///
    /// 返回所有依赖项的检测结果，按输入顺序排列
    pub async fn check_all_dependencies(
        app: AppHandle,
        deps: Vec<Dependency>,
    ) -> Result<Vec<DependencyCheckResult>, ApiError> {
        info!("开始并发检测 {} 个依赖项", deps.len());

        // 使用 Arc<Mutex<>> 收集并发结果，保证线程安全
        let results = Arc::new(Mutex::new(HashMap::new()));
        let total_count = deps.len();

        // 为每个依赖项创建异步检测任务
        let mut tasks = Vec::new();

        for (index, dep) in deps.into_iter().enumerate() {
            let dep_id = dep.id.clone();
            let app_handle = app.clone();
            let results_ref = results.clone();

            let task = tokio::spawn(async move {
                let start_time = std::time::Instant::now();

                // 发射检测开始事件
                debug!("开始检测依赖项: {} (第 {}/{})", dep.name, index + 1, total_count);

                if let Err(e) = app_handle.emit_all("dependency-check-progress", &serde_json::json!({
                    "dependency_id": dep.id,
                    "dependency_name": dep.name,
                    "status": "checking",
                    "current_index": index + 1,
                    "total_count": total_count,
                    "progress_percent": ((index) as f64 / total_count as f64) * 100.0
                })) {
                    warn!("发射检测开始事件失败: {}", e);
                }

                // 执行单个依赖检测
                let check_result = Self::check_single_dependency(&dep).await;
                let duration = start_time.elapsed().as_millis() as u64;

                let final_result = match check_result {
                    Ok(mut result) => {
                        result.duration_ms = duration;
                        info!(
                            "依赖项 {} 检测完成: {} (版本: {:?}, 耗时: {}ms)",
                            dep.name,
                            result.status.description(),
                            result.detected_version,
                            duration
                        );
                        result
                    }
                    Err(e) => {
                        error!("依赖项 {} 检测失败: {}", dep.name, e);
                        DependencyCheckResult::failure(
                            dep.id.clone(),
                            CheckStatus::Corrupted,
                            format!("检测过程出错: {}", e),
                            duration,
                        )
                    }
                };

                // 发射检测完成事件
                let status_str = match final_result.status {
                    CheckStatus::Satisfied => "satisfied",
                    CheckStatus::Missing => "missing",
                    CheckStatus::VersionMismatch => "version_mismatch",
                    CheckStatus::Corrupted => "corrupted",
                };

                if let Err(e) = app_handle.emit_all("dependency-check-progress", &serde_json::json!({
                    "dependency_id": dep.id,
                    "dependency_name": dep.name,
                    "status": status_str,
                    "detected_version": final_result.detected_version,
                    "error_details": final_result.error_details,
                    "current_index": index + 1,
                    "total_count": total_count,
                    "progress_percent": ((index + 1) as f64 / total_count as f64) * 100.0,
                    "duration_ms": duration
                })) {
                    warn!("发射检测完成事件失败: {}", e);
                }

                // 将结果存入共享集合
                let mut results_guard = results_ref.lock().await;
                results_guard.insert(dep_id, final_result);

                debug!("依赖项 {} 的检测结果已保存", dep.name);
            });

            tasks.push(task);
        }

        // 等待所有检测任务完成
        info!("等待 {} 个检测任务完成", tasks.len());

        for (index, task) in tasks.into_iter().enumerate() {
            match task.await {
                Ok(_) => {
                    debug!("检测任务 {}/{} 已完成", index + 1, tasks.len());
                }
                Err(e) => {
                    error!("检测任务 {}/{} 发生panic: {}", index + 1, tasks.len(), e);
                }
            }
        }

        // 收集并排序结果
        let mut results_guard = results.lock().await;
        let collected_results: Vec<DependencyCheckResult> = results_guard
            .drain()
            .map(|(_, result)| result)
            .collect();

        // 按依赖项名称排序以确保结果顺序一致
        let mut sorted_results = collected_results;
        sorted_results.sort_by(|a, b| a.dependency_id.cmp(&b.dependency_id));

        info!("所有依赖项检测完成，共 {} 个结果", sorted_results.len());

        // 统计检测结果
        let satisfied_count = sorted_results.iter().filter(|r| r.is_satisfied()).count();
        let failed_count = sorted_results.len() - satisfied_count;

        info!(
            "依赖检测统计: 满足 {} 个, 失败 {} 个, 成功率 {:.1}%",
            satisfied_count,
            failed_count,
            (satisfied_count as f64 / sorted_results.len() as f64) * 100.0
        );

        Ok(sorted_results)
    }

    /// 检测单个依赖项
    pub async fn check_dependency(&self, dependency: &Dependency) -> Result<DependencyCheckResult, DependencyError> {
        Self::check_single_dependency(dependency).await
    }

    /// 检测单个依赖项的具体实现
    ///
    /// 根据依赖项的检测方法执行相应的检测逻辑
    async fn check_single_dependency(dependency: &Dependency) -> Result<DependencyCheckResult, DependencyError> {
        debug!("检测依赖项: {} (方法: {})", dependency.name, dependency.check_method_name());

        let result = match &dependency.check_method {
            CheckMethod::Executable { name, version_args } => {
                Self::check_executable_dependency(&dependency.id, name, version_args).await?
            }
            CheckMethod::Service { host, port } => {
                Self::check_service_dependency(&dependency.id, host, *port).await?
            }
            CheckMethod::File { path } => {
                Self::check_file_dependency(&dependency.id, path).await?
            }
        };

        // 如果检测到版本，还需要验证版本是否满足要求
        let final_result = if let Some(detected_version) = &result.detected_version {
            let version_valid = Self::validate_version(detected_version, &dependency.version_requirement);
            if version_valid {
                result
            } else {
                DependencyCheckResult::failure(
                    dependency.id.clone(),
                    CheckStatus::VersionMismatch,
                    format!(
                        "版本不满足要求: 检测到 {}, 要求 {}",
                        detected_version, dependency.version_requirement
                    ),
                    result.duration_ms,
                )
            }
        } else {
            result
        };

        Ok(final_result)
    }

    /// 验证版本是否满足要求
    ///
    /// 使用 semver 库进行语义化版本比较，支持各种版本要求格式：
    /// - ">=1.0.0" - 大于等于1.0.0
    /// - "^1.2.3" - 兼容版本，>=1.2.3且<2.0.0
    /// - "~1.2.3" - 近似版本，>=1.2.3且<1.3.0
    /// - "1.2.3" - 精确版本
    fn validate_version(current: &str, required: &str) -> bool {
        debug!("验证版本要求: {} vs {}", current, required);

        // 解析当前版本
        let current_version = match semver::Version::parse(current) {
            Ok(version) => {
                debug!("成功解析当前版本: {}", version);
                version
            }
            Err(err) => {
                warn!("无法解析当前版本 '{}': {}", current, err);
                return false;
            }
        };

        // 解析版本要求
        let version_req = match semver::VersionReq::parse(required) {
            Ok(req) => {
                debug!("成功解析版本要求: {}", req);
                req
            }
            Err(err) => {
                warn!("无法解析版本要求 '{}': {}", required, err);
                return false;
            }
        };

        // 执行版本比较
        let matches = version_req.matches(&current_version);
        debug!(
            "版本比较结果: {} {} {} -> {}",
            current, if matches { "✓" } else { "✗" }, required, matches
        );

        matches
    }

    /// 检测可执行文件依赖
    async fn check_executable_dependency(
        dependency_id: &str,
        name: &str,
        version_args: &[String],
    ) -> Result<DependencyCheckResult, DependencyError> {
        let start_time = std::time::Instant::now();

        // 1. 检查可执行文件是否存在
        let _executable_path = which::which(name).map_err(|e| {
            debug!("未找到可执行文件: {}", name);
            DependencyError::CheckFailed(format!("未找到可执行文件 '{}': {}", name, e))
        })?;

        debug!("找到可执行文件: {:?}", _executable_path);

        // 2. 获取版本号
        let output = tokio::process::Command::new(name)
            .args(version_args)
            .output()
            .await
            .map_err(|e| {
                warn!("执行版本命令失败: {} {:?} - {}", name, version_args, e);
                DependencyError::CheckFailed(format!("执行版本命令失败: {}", e))
            })?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Ok(DependencyCheckResult::failure(
                dependency_id.to_string(),
                CheckStatus::Corrupted,
                format!("版本命令执行失败: {}", stderr.trim()),
                start_time.elapsed().as_millis() as u64,
            ));
        }

        let version_output = String::from_utf8_lossy(&output.stdout);
        let version_str = Self::parse_version_from_output(&version_output);

        match version_str {
            Some(version) => {
                debug!("检测到版本: {} -> {}", name, version);
                Ok(DependencyCheckResult::success(
                    dependency_id.to_string(),
                    Some(version),
                    start_time.elapsed().as_millis() as u64,
                ))
            }
            None => {
                warn!("无法解析版本号: {} {:?}", name, version_args);
                Ok(DependencyCheckResult::failure(
                    dependency_id.to_string(),
                    CheckStatus::Corrupted,
                    "无法解析版本号".to_string(),
                    start_time.elapsed().as_millis() as u64,
                ))
            }
        }
    }

    /// 检测服务依赖
    async fn check_service_dependency(dependency_id: &str, host: &str, port: u16) -> Result<DependencyCheckResult, DependencyError> {
        let start_time = std::time::Instant::now();

        debug!("检测服务连接: {}:{}", host, port);

        // 使用 tokio 尝试连接服务端口
        let socket_addr = format!("{}:{}", host, port);
        match tokio::net::TcpStream::connect(&socket_addr).await {
            Ok(_) => {
                debug!("服务连接成功: {}", socket_addr);
                Ok(DependencyCheckResult::success(
                    format!("{}:{}", host, port),
                    None,
                    start_time.elapsed().as_millis() as u64,
                ))
            }
            Err(e) => {
                warn!("服务连接失败: {} - {}", socket_addr, e);
                Ok(DependencyCheckResult::failure(
                    format!("{}:{}", host, port),
                    CheckStatus::Missing,
                    format!("服务不可达: {}", e),
                    start_time.elapsed().as_millis() as u64,
                ))
            }
        }
    }

    /// 检测文件依赖
    async fn check_file_dependency(path: &str) -> Result<DependencyCheckResult, ApiError> {
        let start_time = std::time::Instant::now();

        debug!("检测文件存在性: {}", path);

        // 使用 tokio 异步检查文件
        match tokio::fs::metadata(path).await {
            Ok(metadata) => {
                debug!("文件存在: {} (大小: {} bytes)", path, metadata.len());
                Ok(DependencyCheckResult::success(
                    path.to_string(),
                    None,
                    start_time.elapsed().as_millis() as u64,
                ))
            }
            Err(e) => {
                warn!("文件不存在或无法访问: {} - {}", path, e);
                Ok(DependencyCheckResult::failure(
                    path.to_string(),
                    CheckStatus::Missing,
                    format!("文件不存在: {}", e),
                    start_time.elapsed().as_millis() as u64,
                ))
            }
        }
    }

    /// 从命令输出中解析版本号
    ///
    /// 支持常见的版本号格式:
    /// - "v20.10.0" -> "20.10.0"
    /// - "node v20.10.0" -> "20.10.0"
    /// - "pnpm 8.15.0" -> "8.15.0"
    /// - "Redis server v=7.2.3" -> "7.2.3"
    fn parse_version_from_output(output: &str) -> Option<String> {
        let trimmed = output.trim();

        // 常见版本号正则模式
        let patterns = [
            r"v?(\d+\.\d+\.\d+)",              // v1.2.3 或 1.2.3
            r"version[:\s]+(\d+\.\d+\.\d+)",   // version: 1.2.3 或 version 1.2.3
            r"(\d+\.\d+\.\d+)[^\d]*$",         // 行尾的版本号
        ];

        for pattern in &patterns {
            if let Ok(regex) = regex::Regex::new(pattern) {
                if let Some(captures) = regex.captures(trimmed) {
                    if let Some(version) = captures.get(1) {
                        return Some(version.as_str().to_string());
                    }
                }
            }
        }

        // 如果正则匹配失败，尝试简单的字符串提取
        let lines: Vec<&str> = trimmed.lines().collect();
        for line in lines {
            let words: Vec<&str> = line.split_whitespace().collect();
            for word in words {
                if word.chars().next().map_or(false, |c| c.is_ascii_digit()) {
                    if let Some(version) = word.trim_start_matches('v').split_whitespace().next() {
                        if version.contains('.') && version.split('.').count() >= 2 {
                            return Some(version.to_string());
                        }
                    }
                }
            }
        }

        warn!("无法从输出中解析版本号: {}", trimmed);
        None
    }
}

impl Default for DependencyChecker {
    fn default() -> Self {
        Self::new()
    }
}
